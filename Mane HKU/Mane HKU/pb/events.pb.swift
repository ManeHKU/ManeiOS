// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Events_EventStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case `open` // = 0
  case closed // = 1
  case unavailable // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .open
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .open
    case 1: self = .closed
    case 2: self = .unavailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .open: return 0
    case .closed: return 1
    case .unavailable: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_EventStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Events_EventStatus] = [
    .open,
    .closed,
    .unavailable,
  ]
}

#endif  // swift(>=4.2)

public enum Events_SortBy: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case createdAt // = 0
  case participationTime // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .createdAt
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .createdAt
    case 1: self = .participationTime
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .createdAt: return 0
    case .participationTime: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_SortBy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Events_SortBy] = [
    .createdAt,
    .participationTime,
  ]
}

#endif  // swift(>=4.2)

public enum Events_EventApplicationStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case applied // = 0
  case removedByAdmin // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .applied
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .applied
    case 1: self = .removedByAdmin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .applied: return 0
    case .removedByAdmin: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_EventApplicationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Events_EventApplicationStatus] = [
    .applied,
    .removedByAdmin,
  ]
}

#endif  // swift(>=4.2)

public struct Events_EventInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var organizerID: String = String()

  public var title: String = String()

  public var imagePath: String {
    get {return _imagePath ?? String()}
    set {_imagePath = newValue}
  }
  /// Returns true if `imagePath` has been explicitly set.
  public var hasImagePath: Bool {return self._imagePath != nil}
  /// Clears the value of `imagePath`. Subsequent reads from it will return its default value.
  public mutating func clearImagePath() {self._imagePath = nil}

  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var location: String = String()

  public var description_p: String = String()

  public var status: Events_EventStatus = .open

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _imagePath: String? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Events_EventParticipation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limit: Int32 = 0

  public var currentCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_OrganizerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _description_p: String? = nil
}

public struct Events_ListLatestEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sortBy: Events_SortBy = .createdAt

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_ListLatestEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Events_ListLatestEventsResponse.FullEventInfo] = []

  public var errorMessage: String {
    get {return _errorMessage ?? String()}
    set {_errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  public var hasErrorMessage: Bool {return self._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  public mutating func clearErrorMessage() {self._errorMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct FullEventInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var event: Events_EventInfo {
      get {return _storage._event ?? Events_EventInfo()}
      set {_uniqueStorage()._event = newValue}
    }
    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool {return _storage._event != nil}
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() {_uniqueStorage()._event = nil}

    public var organizer: Events_OrganizerInfo {
      get {return _storage._organizer ?? Events_OrganizerInfo()}
      set {_uniqueStorage()._organizer = newValue}
    }
    /// Returns true if `organizer` has been explicitly set.
    public var hasOrganizer: Bool {return _storage._organizer != nil}
    /// Clears the value of `organizer`. Subsequent reads from it will return its default value.
    public mutating func clearOrganizer() {_uniqueStorage()._organizer = nil}

    public var participation: Events_EventParticipation {
      get {return _storage._participation ?? Events_EventParticipation()}
      set {_uniqueStorage()._participation = newValue}
    }
    /// Returns true if `participation` has been explicitly set.
    public var hasParticipation: Bool {return _storage._participation != nil}
    /// Clears the value of `participation`. Subsequent reads from it will return its default value.
    public mutating func clearParticipation() {_uniqueStorage()._participation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _errorMessage: String? = nil
}

public struct Events_AddEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var organizerID: String = String()

  public var title: String = String()

  public var imagePath: String {
    get {return _imagePath ?? String()}
    set {_imagePath = newValue}
  }
  /// Returns true if `imagePath` has been explicitly set.
  public var hasImagePath: Bool {return self._imagePath != nil}
  /// Clears the value of `imagePath`. Subsequent reads from it will return its default value.
  public mutating func clearImagePath() {self._imagePath = nil}

  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var location: String = String()

  public var description_p: String = String()

  public var participantLimit: Int32 = 0

  public var applyInfo: Events_ApplyInfo {
    get {return _applyInfo ?? Events_ApplyInfo()}
    set {_applyInfo = newValue}
  }
  /// Returns true if `applyInfo` has been explicitly set.
  public var hasApplyInfo: Bool {return self._applyInfo != nil}
  /// Clears the value of `applyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearApplyInfo() {self._applyInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _imagePath: String? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _applyInfo: Events_ApplyInfo? = nil
}

public struct Events_ApplyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var info: String {
    get {return _info ?? String()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var questions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: String? = nil
}

public struct Events_AddEventResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String {
    get {return _errorMessage ?? String()}
    set {_errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  public var hasErrorMessage: Bool {return self._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  public mutating func clearErrorMessage() {self._errorMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorMessage: String? = nil
}

public struct Events_ApplyEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var answers: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_ApplyEventResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String {
    get {return _errorMessage ?? String()}
    set {_errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  public var hasErrorMessage: Bool {return self._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  public mutating func clearErrorMessage() {self._errorMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorMessage: String? = nil
}

public struct Events_ListUserAppliedEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filterBy: Events_EventApplicationStatus {
    get {return _filterBy ?? .applied}
    set {_filterBy = newValue}
  }
  /// Returns true if `filterBy` has been explicitly set.
  public var hasFilterBy: Bool {return self._filterBy != nil}
  /// Clears the value of `filterBy`. Subsequent reads from it will return its default value.
  public mutating func clearFilterBy() {self._filterBy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filterBy: Events_EventApplicationStatus? = nil
}

public struct Events_ListUserAppliedEventResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: Dictionary<String,Events_EventApplicationStatus> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_GetEventApplyInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_GetEventApplyInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var applyInfo: Events_ApplyInfo {
    get {return _applyInfo ?? Events_ApplyInfo()}
    set {_applyInfo = newValue}
  }
  /// Returns true if `applyInfo` has been explicitly set.
  public var hasApplyInfo: Bool {return self._applyInfo != nil}
  /// Clears the value of `applyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearApplyInfo() {self._applyInfo = nil}

  public var userApplied: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _applyInfo: Events_ApplyInfo? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Events_EventStatus: @unchecked Sendable {}
extension Events_SortBy: @unchecked Sendable {}
extension Events_EventApplicationStatus: @unchecked Sendable {}
extension Events_EventInfo: @unchecked Sendable {}
extension Events_EventParticipation: @unchecked Sendable {}
extension Events_OrganizerInfo: @unchecked Sendable {}
extension Events_ListLatestEventsRequest: @unchecked Sendable {}
extension Events_ListLatestEventsResponse: @unchecked Sendable {}
extension Events_ListLatestEventsResponse.FullEventInfo: @unchecked Sendable {}
extension Events_AddEventRequest: @unchecked Sendable {}
extension Events_ApplyInfo: @unchecked Sendable {}
extension Events_AddEventResponse: @unchecked Sendable {}
extension Events_ApplyEventRequest: @unchecked Sendable {}
extension Events_ApplyEventResponse: @unchecked Sendable {}
extension Events_ListUserAppliedEventRequest: @unchecked Sendable {}
extension Events_ListUserAppliedEventResponse: @unchecked Sendable {}
extension Events_GetEventApplyInfoRequest: @unchecked Sendable {}
extension Events_GetEventApplyInfoResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "events"

extension Events_EventStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN"),
    1: .same(proto: "CLOSED"),
    2: .same(proto: "UNAVAILABLE"),
  ]
}

extension Events_SortBy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATED_AT"),
    1: .same(proto: "PARTICIPATION_TIME"),
  ]
}

extension Events_EventApplicationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLIED"),
    1: .same(proto: "REMOVED_BY_ADMIN"),
  ]
}

extension Events_EventInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "organizer_id"),
    4: .same(proto: "title"),
    5: .standard(proto: "image_path"),
    6: .standard(proto: "start_time"),
    7: .standard(proto: "end_time"),
    8: .same(proto: "location"),
    9: .same(proto: "description"),
    11: .same(proto: "status"),
    12: .standard(proto: "updated_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.organizerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._imagePath) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.organizerID.isEmpty {
      try visitor.visitSingularStringField(value: self.organizerID, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    try { if let v = self._imagePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 8)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 9)
    }
    if self.status != .open {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 11)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_EventInfo, rhs: Events_EventInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.organizerID != rhs.organizerID {return false}
    if lhs.title != rhs.title {return false}
    if lhs._imagePath != rhs._imagePath {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.location != rhs.location {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.status != rhs.status {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_EventParticipation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventParticipation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .standard(proto: "current_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.currentCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    if self.currentCount != 0 {
      try visitor.visitSingularInt32Field(value: self.currentCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_EventParticipation, rhs: Events_EventParticipation) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.currentCount != rhs.currentCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OrganizerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrganizerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_OrganizerInfo, rhs: Events_OrganizerInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ListLatestEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListLatestEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sort_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sortBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sortBy != .createdAt {
      try visitor.visitSingularEnumField(value: self.sortBy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ListLatestEventsRequest, rhs: Events_ListLatestEventsRequest) -> Bool {
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ListLatestEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListLatestEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try { if let v = self._errorMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ListLatestEventsResponse, rhs: Events_ListLatestEventsResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs._errorMessage != rhs._errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ListLatestEventsResponse.FullEventInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Events_ListLatestEventsResponse.protoMessageName + ".FullEventInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "organizer"),
    3: .same(proto: "participation"),
  ]

  fileprivate class _StorageClass {
    var _event: Events_EventInfo? = nil
    var _organizer: Events_OrganizerInfo? = nil
    var _participation: Events_EventParticipation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _event = source._event
      _organizer = source._organizer
      _participation = source._participation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._organizer) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._participation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._organizer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._participation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ListLatestEventsResponse.FullEventInfo, rhs: Events_ListLatestEventsResponse.FullEventInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._event != rhs_storage._event {return false}
        if _storage._organizer != rhs_storage._organizer {return false}
        if _storage._participation != rhs_storage._participation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AddEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "organizer_id"),
    2: .same(proto: "title"),
    3: .standard(proto: "image_path"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
    6: .same(proto: "location"),
    7: .same(proto: "description"),
    8: .standard(proto: "participant_limit"),
    9: .standard(proto: "apply_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.organizerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._imagePath) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.participantLimit) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._applyInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.organizerID.isEmpty {
      try visitor.visitSingularStringField(value: self.organizerID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try { if let v = self._imagePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if self.participantLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.participantLimit, fieldNumber: 8)
    }
    try { if let v = self._applyInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_AddEventRequest, rhs: Events_AddEventRequest) -> Bool {
    if lhs.organizerID != rhs.organizerID {return false}
    if lhs.title != rhs.title {return false}
    if lhs._imagePath != rhs._imagePath {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.location != rhs.location {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.participantLimit != rhs.participantLimit {return false}
    if lhs._applyInfo != rhs._applyInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ApplyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "questions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._info) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.questions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.questions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.questions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ApplyInfo, rhs: Events_ApplyInfo) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.questions != rhs.questions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AddEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddEventResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._errorMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_AddEventResponse, rhs: Events_AddEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._errorMessage != rhs._errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ApplyEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_id"),
    2: .same(proto: "answers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.answers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.answers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.answers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ApplyEventRequest, rhs: Events_ApplyEventRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ApplyEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyEventResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._errorMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ApplyEventResponse, rhs: Events_ApplyEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._errorMessage != rhs._errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ListUserAppliedEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUserAppliedEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filterBy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._filterBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filterBy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ListUserAppliedEventRequest, rhs: Events_ListUserAppliedEventRequest) -> Bool {
    if lhs._filterBy != rhs._filterBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ListUserAppliedEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUserAppliedEventResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Events_EventApplicationStatus>.self, value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Events_EventApplicationStatus>.self, value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ListUserAppliedEventResponse, rhs: Events_ListUserAppliedEventResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_GetEventApplyInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventApplyInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_GetEventApplyInfoRequest, rhs: Events_GetEventApplyInfoRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_GetEventApplyInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventApplyInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "apply_info"),
    2: .standard(proto: "user_applied"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._applyInfo) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.userApplied) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._applyInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.userApplied != false {
      try visitor.visitSingularBoolField(value: self.userApplied, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_GetEventApplyInfoResponse, rhs: Events_GetEventApplyInfoResponse) -> Bool {
    if lhs._applyInfo != rhs._applyInfo {return false}
    if lhs.userApplied != rhs.userApplied {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
